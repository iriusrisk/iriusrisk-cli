# IriusRisk Threat Model Creation Instructions for AI Assistants

## üö® CRITICAL VALIDATION RULES - READ FIRST

**Before creating ANY OTM file, you MUST:**

1. **Open and read `.iriusrisk/trust-zones.json`**
   - EVERY trust zone ID you use MUST be a UUID from this file's `id` field
   - Example: `"id": "b61d6911-338d-46a8-9f39-8dcd24abfe91"` (NOT "internet" or "public-cloud")
   - DO NOT invent trust zone IDs

2. **Open and read `.iriusrisk/components.json`**
   - EVERY component type you use MUST be a complete `referenceId` from this file
   - Filter out deprecated: skip if `category.name == "Deprecated"` or `name` starts with "Deprecated - "
   - Example: `"CD-V2-AWS-ECS-CLUSTER"` (NOT "CD-AWS-ECS" or "ecs-cluster")
   - DO NOT abbreviate or invent component types

3. **Validate EVERY component and trust zone before creating OTM**
   - Search components.json for each component type
   - Search trust-zones.json for each trust zone ID
   - If not found: use generic type or ask user

**These files are downloaded by sync() - you MUST read them before creating OTM.**

## Executive Summary

Create OTM files to model system architecture for IriusRisk threat analysis. Your role: architecture modeling only (components, trust zones, data flows). Do NOT create threats or controls‚ÄîIriusRisk generates those automatically.

**Standard workflow:** 
1. **sync()** - Downloads trust-zones.json, components.json, current-threat-model.otm
2. **READ trust-zones.json and components.json** - Validate IDs/types exist
3. Check `.iriusrisk/current-threat-model.otm` - Merge if exists
4. Create OTM in `.iriusrisk/temp-*.otm` with validated IDs/types
5. import_otm() ‚Üí project_status() ‚Üí **STOP**

## Quick Reference

**File locations:**
- Save OTM to: `.iriusrisk/temp-initial.otm` or `.iriusrisk/temp-update-YYYYMMDD-HHMMSS.otm`
- Read current state from: `.iriusrisk/current-threat-model.otm` (if exists)

**Workflow:**
1. sync() ‚Üí 2. Read validation files ‚Üí 3. Create/merge OTM ‚Üí 4. import_otm()

**Dataflows:** Connect components ONLY (never trust zones)

## Merge Logic - Single-Repo and Multi-Repo Are IDENTICAL

**Whether updating from same repo or different repo, the workflow is IDENTICAL:**
1. sync() downloads `.iriusrisk/current-threat-model.otm`
2. If exists: READ it, preserve ALL components/IDs/layout, add NEW components
3. If not: CREATE initial model
4. Save to `.iriusrisk/temp-*.otm`

**For detailed layout guidance:** Call `otm_layout_guidance()` MCP tool
**For detailed validation guidance:** Call `otm_validation_guidance()` MCP tool

## Merging with Existing Threat Models

**If `.iriusrisk/current-threat-model.otm` exists:**
1. Read and parse the file
2. Preserve ALL existing components, IDs, and layout positions
3. Add your NEW components
4. Update parent relationships if needed (e.g., app runs in infrastructure)
5. Add new dataflows

**Check `.iriusrisk/project.json` for scope** - guides what to add:
- Infrastructure scope: Add cloud resources, wrap existing apps
- Application scope: Add services, connect to existing infrastructure
- Frontend scope: Add client components, connect to backend

**For detailed merge examples:** See end of this document

## Component Layout

**Basic rules:**
- Preserve existing positions when updating
- Leaf components: 85x85 pixels
- Container components: Calculate from children (child_area + 80px padding, min 200x200)
- Spacing: 50-100px between components

**If `reset_layout=True` or `auto_reset_layout: true`:**
- DO NOT include `representation` sections
- Backend strips all layout data
- IriusRisk auto-layouts from scratch

**For detailed positioning algorithms:** Call `otm_layout_guidance()` MCP tool


**Use standard (single-repo) workflow when:**
- `.iriusrisk/project.json` doesn't exist (new project)
- `project_id` field is missing (project not yet created)
- No `scope` field present (single repository project)
- User explicitly states this is a new, independent project

## Common Errors to Avoid

**Error 1: Dataflows use trust zone IDs**
- ‚ùå WRONG: `source: "internet"` (trust zone)
- ‚úÖ CORRECT: `source: "mobile-app"` (component)
- Rule: Dataflows connect components ONLY

**Error 2: Abbreviated component types**
- ‚ùå WRONG: `type: "CD-AWS-ECS"` (abbreviated)
- ‚úÖ CORRECT: `type: "CD-V2-AWS-ECS-CLUSTER"` (complete referenceId)
- Rule: Use COMPLETE referenceId from components.json

**Error 3: Using deprecated components**
- Filter out: `category.name == "Deprecated"` or `name` starts with "Deprecated - "
- ~40% of components are deprecated

**Error 4: Changing project.id**
- ‚ùå NEVER change project.id when updating
- ‚úÖ ALWAYS preserve exact project.id from existing OTM or project.json reference_id

**For detailed validation guidance:** Call `otm_validation_guidance()` MCP tool

## Your Role: Architecture Modeling Only

**Do:**
- Extract components from source code, infrastructure, documentation
- Map components to IriusRisk types using exact referenceId values
- Define trust zones and component relationships
- Create data flows between components

**Do NOT:**
- Identify threats, vulnerabilities, or security flaws
- Create mitigations, controls, or countermeasures
- Add threats/mitigations sections to OTM file
- Analyze code for security issues
- Run CLI commands like `iriusrisk component search`

**Why:** IriusRisk automatically generates all threats and controls after OTM import.

## Tags - Architecture ONLY

**Tags describe WHAT components ARE, not WHAT'S WRONG with them.**

**Good tags:** `payment-processing`, `pci-dss-scope`, `public-facing`, `customer-data`
**Bad tags:** `sql-injection-vulnerable`, `weak-crypto`, `no-validation`

IriusRisk finds vulnerabilities automatically - don't add them as tags.

```yaml
# ‚úÖ CORRECT - Architectural/functional tags
components:
  - id: "payment-api"
    name: "Payment Service"
    type: "CD-V2-WEB-SERVICE"
    tags:
      - "pci-dss-scope"           # Compliance scope
      - "payment-processing"      # Business function
      - "customer-data"           # Data sensitivity
      - "high-availability"       # Operational requirement
      - "public-facing"           # Exposure level

dataflows:
  - id: "app-to-payment"
    source: "web-app"
    destination: "payment-api"
    tags:
      - "credit-card-data"        # Data type flowing
      - "encrypted-in-transit"    # Security control present
      - "pci-dss-boundary"        # Compliance boundary
```

### What Tags Are NOT For

**‚ùå NEVER use tags to document vulnerabilities or security flaws you find in code:**

```yaml
# ‚ùå WRONG - Vulnerability tags (DO NOT DO THIS)
components:
  - id: "flask-app"
    name: "Flask API"
    type: "CD-V2-WEB-SERVICE"
    tags:
      - "sql-injection-vulnerable"      # ‚ùå This is a THREAT, not architecture
      - "insecure-deserialization"      # ‚ùå This is a VULNERABILITY
      - "command-injection-vulnerable"  # ‚ùå This is a SECURITY FLAW
      - "sensitive-data-exposure"       # ‚ùå This is a WEAKNESS

dataflows:
  - id: "app-to-db"
    source: "flask-app"
    destination: "database"
    tags:
      - "sql-injection-vulnerable"   # ‚ùå NO! This is a threat
      - "no-parameterization"        # ‚ùå NO! This is an implementation flaw
      - "arbitrary-code-execution"   # ‚ùå NO! This is a vulnerability
```

### Why This Matters

1. **IriusRisk identifies vulnerabilities** - The threat library contains thousands of threats based on component types and patterns. Your job is to model the architecture correctly, and IriusRisk will identify the relevant threats.

2. **Tags clutter the diagram** - Vulnerability tags appear as labels on the diagram, making it unreadable and unprofessional.

3. **Mixes concerns** - The OTM describes "what is" (architecture), not "what's wrong" (threats). Threats come from IriusRisk's rules engine after import.

4. **Makes threat modeling subjective** - Different analysts would add different vulnerability tags. The architecture should be objective.

5. **Defeats the purpose** - If you manually tag all vulnerabilities, why use IriusRisk's automated threat detection?

### When You Find Vulnerabilities in Code

**If you notice vulnerabilities while analyzing source code (SQL injection, weak crypto, etc.):**

1. ‚úÖ **DO** model the architecture accurately (component types, data flows)
2. ‚úÖ **DO** use appropriate component types that will trigger threat detection (e.g., `CD-V2-WEB-SERVICE` for SQL injection prone components)
3. ‚úÖ **DO** note code issues in your analysis comments or report to the user
4. ‚ùå **DO NOT** add vulnerability tags to the OTM
5. ‚ùå **DO NOT** try to manually enumerate threats in the architecture

**Trust IriusRisk to find the threats based on your accurate architecture modeling.**

### Good Tag Examples

**Architectural purpose:**
- `authentication-service`
- `payment-processing`
- `user-registration`
- `admin-functionality`

**Data sensitivity:**
- `pii-processing`
- `financial-data`
- `health-records`
- `customer-data`

**Compliance scope:**
- `pci-dss-scope`
- `hipaa-scope`
- `gdpr-relevant`
- `sox-controls`

**Operational characteristics:**
- `public-facing`
- `internal-only`
- `high-availability`
- `batch-processing`

**Network exposure:**
- `internet-accessible`
- `vpn-only`
- `private-network`

### Bad Tag Examples (NEVER USE)

**Vulnerability/weakness tags:**
- ‚ùå `sql-injection-vulnerable`
- ‚ùå `xss-vulnerable`
- ‚ùå `insecure-deserialization`
- ‚ùå `command-injection`
- ‚ùå `weak-crypto`
- ‚ùå `hardcoded-credentials`

**Implementation flaw tags:**
- ‚ùå `no-parameterization`
- ‚ùå `no-validation`
- ‚ùå `unauthenticated`
- ‚ùå `unencrypted`
- ‚ùå `pickle-serialization`

**Security finding tags:**
- ‚ùå `ssrf-vulnerable`
- ‚ùå `csrf-vulnerable`
- ‚ùå `arbitrary-code-execution`
- ‚ùå `untrusted-input`
- ‚ùå `sensitive-data-exposure`

### Rule of Thumb

**Ask yourself: "Is this tag describing WHAT the component IS, or WHAT'S WRONG with it?"**

- If it describes **what it is** ‚Üí ‚úÖ Good tag
- If it describes **what's wrong** ‚Üí ‚ùå Bad tag (let IriusRisk find the vulnerability)

### Summary

**Tags = Architecture categorization**  
**Threats = IriusRisk's job**

Do not conflate these. Model the architecture accurately, use meaningful architectural tags, and trust IriusRisk to identify all the vulnerabilities.

## Required Workflow Checklist

**üö® VALIDATION RULE - READ THIS FIRST:**
- **EVERY component type** you use MUST exist in `.iriusrisk/components.json` - Open the file and verify!
- **EVERY trust zone ID** you use MUST exist in `.iriusrisk/trust-zones.json` - Open the file and verify!
- **DO NOT invent components or trust zones** - If you can't find an exact match, use a generic type or ask
- This is THE MOST COMMON failure mode - always validate before creating OTM!

**Complete steps 0-8, then STOP and wait for user.** Step 9 only when user explicitly requests.

- ‚òê Step 0: **sync(project_path)** - MANDATORY FIRST STEP
  - Downloads components.json, trust-zones.json
  - Downloads current-threat-model.otm if project exists
  - This is REQUIRED before any analysis
  
- ‚òê Step 1: **CHECK `.iriusrisk/current-threat-model.otm`** (downloaded by sync)
  - **If exists**: MERGE mode - read entire file, preserve everything
  - **If missing**: CREATE mode - but still check project.json
  
- ‚òê Step 2: Analyze source material
  - Identify NEW components to add from THIS repository
  - If MERGE mode: Focus on what's NEW (don't duplicate existing)
  
- ‚òê Step 3: Check `.iriusrisk/project.json` - Read project name/ID/scope
  
- ‚òê Step 4: Create merged OTM file
  - **MERGE mode**: Use IDENTICAL logic as multi-repo workflow
    - Preserve ALL existing components with their IDs
    - Preserve ALL layout positions (x, y, width, height)
    - Add NEW components with calculated positions
    - Recalculate parent container sizes if needed
  - **CREATE mode**: All components from analysis
  - **Save to**: `.iriusrisk/temp-update-YYYYMMDD-HHMMSS.otm` (or temp-initial.otm)
  
- ‚òê Step 5: Validate components - Use exact referenceId from components.json
  
- ‚òê Step 6: **import_otm(".iriusrisk/temp-update-*.otm")** - Upload temporary file
  - Backend automatically validates against OTM JSON schema
  - If validation fails, you'll see clear error messages
  - Fix any structural issues before proceeding
  
- ‚òê Step 7: **project_status()** - Verify project ready
  
- ‚òê Step 8: Present results - Offer options - **STOP HERE and wait for user**
  
- ‚òê Step 9: **sync()** again - **ONLY if user explicitly requests** - Download updated threats/countermeasures

**üö® REMEMBER: If user said "threat model [X]", you are doing architecture modeling. DO NOT call threats_and_countermeasures() or analyze threats.json.**

## Detailed Workflow

### Step 0: sync(project_path) - Download Component Library, Trust Zones, AND Current Threat Model

**Mandatory first step.** Call sync() with full absolute project path (e.g., `sync("/Users/username/my-project")`).

**What it does:**
- Downloads complete IriusRisk component library to `.iriusrisk/components.json`
- Downloads trust zones to `.iriusrisk/trust-zones.json` ‚ö†Ô∏è CRITICAL
- **Downloads current threat model to `.iriusrisk/current-threat-model.otm`** ‚ö†Ô∏è NEW
- If project exists, also downloads current threats/countermeasures/questionnaires
- Prevents OTM import failures due to unknown component types or trust zones

**‚ö†Ô∏è CRITICAL FILES TO CHECK AFTER SYNC (THESE ARE YOUR VALIDATION SOURCES):**
1. **`.iriusrisk/trust-zones.json`** - ‚ö†Ô∏è EVERY trust zone ID MUST come from this file - DO NOT invent IDs
2. **`.iriusrisk/components.json`** - ‚ö†Ô∏è EVERY component type MUST exist in this file - DO NOT invent types
3. **`.iriusrisk/current-threat-model.otm`** - If exists, you are UPDATING existing model (merge required)
4. **`.iriusrisk/project.json`** - Check for scope definition

**VALIDATION REQUIREMENT:** Before creating your OTM, you MUST open components.json and trust-zones.json and verify every single component type and trust zone ID you plan to use actually exists in those files. This is not optional.

**Decision Logic After Step 0:**
- **If `current-threat-model.otm` exists**: This is an UPDATE/MERGE workflow - read and merge with existing OTM
- **If no `current-threat-model.otm`**: This is a NEW threat model - create from scratch

### Step 1: Check for Existing Threat Model (AFTER sync())

**üö® MANDATORY: sync() has already downloaded `.iriusrisk/current-threat-model.otm` if project exists**

```python
# Check if file exists (downloaded by sync)
from pathlib import Path
otm_file = Path('.iriusrisk/current-threat-model.otm')
if otm_file.exists():
    # READ IT IMMEDIATELY
    with open(otm_file, 'r') as f:
        existing_otm = f.read()
    print(f"Found existing threat model: {len(existing_otm)} bytes")
    # YOU ARE IN MERGE MODE - use IDENTICAL logic as multi-repo workflow
else:
    print("No existing threat model - creating initial model")
    # YOU ARE IN CREATE MODE
```

**If this file exists (MERGE MODE):**
- ‚úÖ **YOU ARE UPDATING** - use IDENTICAL merge logic as multi-repo workflow
- ‚úÖ **READ and parse the entire file** to understand:
  - Existing components and their IDs (PRESERVE these)
  - Component layout positions: x, y, width, height (PRESERVE these)
  - Trust zones and their IDs
  - Data flows
  - Project ID (NEVER change this)
- ‚úÖ Your job is to ADD components, not replace
- ‚úÖ Preserve all existing layout information
- ‚úÖ Calculate positions for new components that fit with existing layout
- ‚úÖ Use the SAME merge algorithm as multi-repo contributions

**If this file does NOT exist (CREATE MODE):**
- You are creating initial threat model
- Still check `.iriusrisk/project.json` for existing project info
- Create `.iriusrisk/temp-initial.otm`
- After import, future updates will use MERGE MODE

### Step 2: Analyze Source & Check Configuration

**FIRST: Check for existing threat model:**
- **You already checked for `.iriusrisk/current-threat-model.otm`** in Step 1
- If it exists and you read it, you know existing architecture
- Your analysis should focus on ADDING to it, not duplicating
- **IGNORE any OTM files in the repo root** - they are obsolete bootstrap files

**Check for existing project:**
- Look for `.iriusrisk/project.json`
- If exists, use `name` and `reference_id` from that file (the `reference_id` will be used as the OTM `project.id`)
- Check for `scope` field to understand this repository's role
- If not exists, create descriptive names from source material

**Analyze source material:**
- Identify infrastructure (VMs, containers, databases, load balancers)
- Identify business logic (auth services, payment processing, user management)
- Identify data components (databases, storage, queues, caches)
- Identify external systems (third-party APIs, services)
- Plan nesting (business logic runs within infrastructure)
- Identify data flows between components
- **If existing OTM exists**: Plan how to integrate your components with existing ones
- **Do NOT identify threats or security issues**

### Step 3: Create OTM File in `.iriusrisk/` Directory

**MANDATORY FILE LOCATION:** ALL OTM files MUST be saved in `.iriusrisk/` directory.

**File naming:**
- **For updates**: `.iriusrisk/temp-update-YYYYMMDD-HHMMSS.otm`
  - Example: `.iriusrisk/temp-update-20260206-143022.otm`
- **For initial creation**: `.iriusrisk/temp-initial.otm`

**Use project.json if exists:** Read `.iriusrisk/project.json` and use `name` and `reference_id` from that file. The `reference_id` becomes the `project.id` in your OTM file. Otherwise, create descriptive names.

**NEVER create OTM files in repository root** - they must be in `.iriusrisk/` with clear temporary naming.

## CRITICAL: Trust Zone Setup

**‚ö†Ô∏è MANDATORY: Read `.iriusrisk/trust-zones.json` file FIRST**

**üö® ABSOLUTE RULE: EVERY trust zone ID you use MUST exist in `.iriusrisk/trust-zones.json`. If it's not in that file, you CANNOT use it.**

Before creating your OTM file, you MUST:
1. **Open and read** `.iriusrisk/trust-zones.json` (created by sync() in Step 0)
2. **Identify which trust zones you need** from the available zones in the file
3. **Copy the EXACT `id` field values** from trust-zones.json (these are UUIDs like "b61d6911-338d-11e8-8c37-ad2a1d5c1e0c")
4. **Verify each trust zone ID** before using it in your OTM

**DO NOT:**
- Invent trust zone names or IDs (e.g., "internet", "dmz", "application" - these are NOT IDs)
- Use descriptive names instead of actual UUID IDs
- Create new trust zones not in trust-zones.json
- Assume a trust zone exists without checking the file
- Use trust zone names as IDs (use the UUID from the `id` field, not the `name` field)

**Trust zones in OTM file:**
```yaml
trustZones:
  # Copy trust zones you need from trust-zones.json
  # Use EXACT id values from that file
  - id: "b61d6911-338d-11e8-8c37-ad2a1d5c1e0c"  # Example: actual UUID from trust-zones.json
    name: "Internet"  # Can use descriptive name
    risk:
      trustRating: 1  # Use trustRating from trust-zones.json
```

**Example trust-zones.json structure:**
```json
[
  {
    "id": "b61d6911-338d-11e8-8c37-ad2a1d5c1e0c",
    "name": "Internet",
    "risk": {
      "trustRating": 1
    }
  },
  {
    "id": "f0ba7722-39b6-4c81-8290-a30a248bb8d9",
    "name": "Public Cloud",
    "risk": {
      "trustRating": 5
    }
  }
]
```

## Parent Relationship Rules

**‚ö†Ô∏è CRITICAL: Every component MUST have a parent - either a trust zone ID or a component ID. Components cannot exist without a parent.**

**Simple principle:** A component's parent represents WHERE it physically resides or executes.

**Use `parent: { trustZone: "zone-id" }` when:**
- The component is standalone infrastructure (VPCs, networks, databases, storage)
- The component is externally hosted (third-party APIs, SaaS services)
- The component has no containing infrastructure in your model
- **IMPORTANT:** Use exact trust zone ID from trust-zones.json

**Use `parent: { component: "component-id" }` when:**
- The component runs inside another component
- Examples: Application runs in VM, Service runs in container, Function runs in serverless platform
- **IMPORTANT:** The parent component must be defined before (above) this component in the OTM file

**Common patterns:**
- Network infrastructure ‚Üí trust zone parent (use ID from trust-zones.json)
- Compute infrastructure (VM, container platform) ‚Üí trust zone parent (use ID from trust-zones.json)
- Applications/services running on compute ‚Üí component parent (the compute hosting it)
- Databases/storage ‚Üí trust zone parent (use ID from trust-zones.json)
- External/third-party services ‚Üí trust zone parent (typically an "internet" or "external" zone ID from trust-zones.json)

**‚ö†Ô∏è REMEMBER: Trust zones define LOCATION. Components define THINGS. Dataflows connect THINGS (components), not locations (trust zones).**

## Complete Example

**IMPORTANT:** This example uses placeholder trust zone IDs. In reality, you MUST read `.iriusrisk/trust-zones.json` and use the actual IDs from that file.

```yaml
otmVersion: 0.1.0
project:
  name: "[from project.json 'name' field or descriptive name]"
  id: "[from project.json 'reference_id' field or generate unique ID]"
  description: "[brief system description]"

trustZones:
  # ‚ö†Ô∏è These IDs are examples - read trust-zones.json for actual IDs
  # Copy the trust zones you need from trust-zones.json
  - id: "b61d6911-338d-11e8-8c37-ad2a1d5c1e0c"  # Example: actual ID from trust-zones.json
    name: "Internet"
    risk:
      trustRating: 1
  - id: "2ab4effa-40b4-45de-ba93-9e4c3d4db85a"  # Example: actual ID from trust-zones.json
    name: "Public Cloud"
    risk:
      trustRating: 3
  - id: "f0ba7722-39b6-4c81-8290-a30a248bb8d9"  # Example: actual ID from trust-zones.json
    name: "Private Secured"
    risk:
      trustRating: 10

components:
  # External client - in internet zone
  # ‚ö†Ô∏è trustZone value MUST be an ID from trust-zones.json
  - id: "web-browser"
    name: "Web Browser"
    type: "[exact referenceId from components.json]"
    parent:
      trustZone: "b61d6911-338d-11e8-8c37-ad2a1d5c1e0c"  # Internet zone ID from trust-zones.json
  
  # Load balancer - standalone in public cloud zone
  # ‚ö†Ô∏è trustZone value MUST be an ID from trust-zones.json
  - id: "alb"
    name: "Application Load Balancer"
    type: "[exact referenceId from components.json]"
    parent:
      trustZone: "2ab4effa-40b4-45de-ba93-9e4c3d4db85a"  # Public Cloud zone ID from trust-zones.json
  
  # Container platform - standalone in public cloud zone
  # ‚ö†Ô∏è trustZone value MUST be an ID from trust-zones.json
  - id: "ecs-cluster"
    name: "ECS Cluster"
    type: "[exact referenceId from components.json]"
    parent:
      trustZone: "2ab4effa-40b4-45de-ba93-9e4c3d4db85a"  # Public Cloud zone ID from trust-zones.json
  
  # Application services - run inside container platform
  - id: "auth-service"
    name: "Authentication Service"
    type: "[exact referenceId from components.json]"
    parent:
      component: "ecs-cluster"  # runs in ECS
  
  - id: "api-service"
    name: "API Service"
    type: "[exact referenceId from components.json]"
    parent:
      component: "ecs-cluster"  # runs in ECS
  
  # Database - standalone in private secured zone
  # ‚ö†Ô∏è trustZone value MUST be an ID from trust-zones.json
  - id: "user-db"
    name: "User Database"
    type: "[exact referenceId from components.json]"
    parent:
      trustZone: "f0ba7722-39b6-4c81-8290-a30a248bb8d9"  # Private Secured zone ID from trust-zones.json
  
  # External API - in internet zone
  # ‚ö†Ô∏è trustZone value MUST be an ID from trust-zones.json
  - id: "payment-api"
    name: "Payment Processor API"
    type: "[exact referenceId from components.json]"
    parent:
      trustZone: "b61d6911-338d-11e8-8c37-ad2a1d5c1e0c"  # Internet zone ID from trust-zones.json

dataflows:
  # ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CRITICAL: Dataflows ONLY connect components (never trust zones) ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
  # Use component IDs like "web-browser", "alb", "api-service" (defined above)
  # NEVER use trust zone IDs like "internet", "dmz", "application" in dataflows
  
  - id: "user-request"
    source: "web-browser"      # component ID ‚úÖ
    destination: "alb"          # component ID ‚úÖ
  
  - id: "alb-to-api"
    source: "alb"               # component ID ‚úÖ
    destination: "api-service"  # component ID ‚úÖ
  
  - id: "api-to-auth"
    source: "api-service"       # component ID ‚úÖ
    destination: "auth-service" # component ID ‚úÖ
  
  - id: "auth-to-db"
    source: "auth-service"      # component ID ‚úÖ
    destination: "user-db"      # component ID ‚úÖ
  
  - id: "api-to-payment"
    source: "api-service"       # component ID ‚úÖ
    destination: "payment-api"  # component ID ‚úÖ

# Do NOT add: threats, mitigations, controls (IriusRisk generates these)
```

## Invalid Examples - Common Mistakes

```yaml
# ‚ùå WRONG #1: Inventing trust zone IDs instead of using trust-zones.json
# This causes "not existing TrustZone" errors
components:
  - id: "my-cluster"
    parent:
      trustZone: "application"  # ‚ùå Made-up name - FAILS
  - id: "my-db"
    parent:
      trustZone: "secure-zone"  # ‚ùå Invented ID - FAILS

# ‚úÖ CORRECT: Read trust-zones.json and use actual IDs
components:
  - id: "my-cluster"
    parent:
      trustZone: "f0ba7722-39b6-4c81-8290-a30a248bb8d9"  # ‚úÖ Real ID from trust-zones.json
  - id: "my-db"
    parent:
      trustZone: "f0ba7722-39b6-4c81-8290-a30a248bb8d9"  # ‚úÖ Real ID from trust-zones.json

# ‚ùå WRONG #2: Referencing non-existent component in parent
# This causes import failures
components:
  - id: "my-service"
    parent:
      component: "my-container-platform"  # ‚ùå This component doesn't exist!

# ‚úÖ CORRECT: Parent component must be defined first (earlier in components list)
components:
  - id: "my-container-platform"
    type: "CD-V2-CONTAINER-PLATFORM"
    parent:
      trustZone: "f0ba7722-39b6-4c81-8290-a30a248bb8d9"
  
  - id: "my-service"
    parent:
      component: "my-container-platform"  # ‚úÖ References component defined above

# ‚ùå WRONG #3: Referencing non-existent component in dataflow
# This causes import failures
dataflows:
  - id: "data-flow"
    source: "api-gateway"  # ‚ùå This component doesn't exist in components section!
    destination: "my-service"

# ‚úÖ CORRECT: Both components must exist in components section
components:
  - id: "api-gateway"
    type: "CD-V2-API-GATEWAY"
    parent:
      trustZone: "f0ba7722-39b6-4c81-8290-a30a248bb8d9"
  - id: "my-service"
    type: "CD-V2-WEB-SERVICE"
    parent:
      trustZone: "f0ba7722-39b6-4c81-8290-a30a248bb8d9"

dataflows:
  - id: "data-flow"
    source: "api-gateway"  # ‚úÖ Exists in components above
    destination: "my-service"  # ‚úÖ Exists in components above

# ‚ùå WRONG #4: Component with no parent
- id: "my-service"
  name: "My Service"
  type: "CD-V2-WEB-SERVICE"
  # ‚ùå Missing parent! Every component MUST have a parent

# ‚úÖ CORRECT: Every component has a parent
- id: "my-service"
  name: "My Service"
  type: "CD-V2-WEB-SERVICE"
  parent:
    trustZone: "f0ba7722-39b6-4c81-8290-a30a248bb8d9"  # ‚úÖ Has parent

# ‚ùå WRONG #5: Using trust zone IDs in dataflows (ALSO VERY COMMON)
dataflows:
  - id: "bad-flow"
    source: "b61d6911-338d-11e8-8c37-ad2a1d5c1e0c"  # ‚ùå Trust zone ID - FAILS
    destination: "f0ba7722-39b6-4c81-8290-a30a248bb8d9"  # ‚ùå Trust zone ID - FAILS

# Why wrong? Trust zones are containers/locations, not things that communicate.
# You can't send data "to a zone" - you send it to a component IN the zone.

# ‚ùå WRONG #6: Service nested in load balancer
# Load balancers route TO services, they don't host them
- id: "my-service"
  parent:
    component: "load-balancer"  # WRONG

# ‚ùå WRONG #7: Using deprecated component (VERY COMMON - 40% are deprecated!)
- id: "my-webapp"
  type: "microsoft-azure-web-apps"  # ‚ùå Deprecated component
  # In components.json this has:
  # "name": "Deprecated - Azure Web Apps"
  # "category": {"name": "Deprecated"}

# ‚úÖ CORRECT: Use active, non-deprecated component
- id: "my-webapp"  
  type: "CD-V2-AZURE-WEB-APPS"  # ‚úÖ Active version
  # In components.json this has:
  # "name": "Azure Web Apps" (no "Deprecated -" prefix)
  # "category": {"name": "Microsoft Azure"}

# ‚ùå WRONG #8: Abbreviated or truncated component type
- id: "my-waf"
  type: "CD-V2-AWS-WAF"  # ‚ùå Truncated - missing rest of referenceId

- id: "my-db"
  type: "postgres"  # ‚ùå Wrong - not exact referenceId

- id: "my-cluster"
  type: "CD-V2-ECS"  # ‚ùå Abbreviated - not complete referenceId

# ‚úÖ CORRECT - Use COMPLETE referenceId from components.json:
- id: "my-waf"
  type: "CD-V2-AWS-WAF-WEB-APPLICATION-FIREWALL"  # ‚úÖ Complete string

- id: "my-db"
  type: "CD-V2-POSTGRESQL-DATABASE"  # ‚úÖ Full referenceId

- id: "my-cluster"
  type: "CD-V2-AWS-ECS-CLUSTER"  # ‚úÖ Full referenceId

# ‚úÖ CORRECT alternatives:
# Service runs in compute infrastructure (VM/container/serverless)
- id: "my-service"
  parent:
    component: "ecs-cluster"  # Runs in ECS

# Or if no compute infrastructure is modeled:
- id: "my-service"
  parent:
    trustZone: "application"  # Standalone in app zone

# Dataflow connects components
dataflows:
  - id: "good-flow"
    source: "load-balancer"  # Component ID
    destination: "my-service"  # Component ID

# Use exact referenceId from components.json
- id: "my-db"
  type: "CD-V2-POSTGRESQL-DATABASE"  # Exact referenceId
```

### Step 4: Map Components to IriusRisk Types and VALIDATE

**üö® THIS IS THE MOST CRITICAL STEP - 80% OF FAILURES HAPPEN HERE**

**‚ö†Ô∏è MANDATORY: Open and read `.iriusrisk/components.json`** (created by sync() in Step 0). This file contains all valid component types.

**‚ö†Ô∏è CRITICAL: Use the COMPLETE referenceId - DO NOT abbreviate, truncate, shorten, or INVENT it.**

**‚ö†Ô∏è ABSOLUTE RULE: If a component type is NOT in components.json, you CANNOT use it. Do NOT invent component types.**

**Mapping and Validation Process (FOLLOW EVERY STEP):**
1. **Open `.iriusrisk/components.json`** in your editor/viewer
2. **For each component** you identified in Step 1, search the file for keywords (e.g., "WAF", "database", "ECS", "lambda")
3. **FILTER OUT DEPRECATED COMPONENTS** - Skip any component where:
   ```
   component["category"]["name"] == "Deprecated" OR
   component["name"].startswith("Deprecated - ")
   ```
   Note: ~40% of components are deprecated. If you find a deprecated match, keep searching for an active alternative.
4. **Find the matching ACTIVE component entry** - Read the `name` field to confirm it's what you need
5. **Copy the ENTIRE `referenceId` field value** - Do not modify, abbreviate, truncate, or invent anything
6. **Paste it exactly** as the `type` in your OTM component
7. **If no active match found** - Use a generic component type OR ask the user - **DO NOT invent a type or use deprecated**
8. **Double-check** - Before moving to next component, verify you copied from the file (not from memory/pattern)

**VALIDATION CHECKPOINT:** Before proceeding to Step 5, go through your OTM and verify you can find EVERY component type in components.json. If you can't find it, you must change it.

**Common error pattern - DO NOT DO THIS:**
```json
// In components.json you find:
{
  "name": "AWS WAF Web Application Firewall",
  "referenceId": "CD-V2-AWS-WAF-WEB-APPLICATION-FIREWALL"
}
```

```yaml
# ‚ùå WRONG - Abbreviated/truncated:
- id: "my-waf"
  type: "CD-V2-AWS-WAF"  # FAILS - missing "-WEB-APPLICATION-FIREWALL"

# ‚ùå WRONG - Simplified:
- id: "my-waf"
  type: "CD-V2-WAF"  # FAILS - truncated

# ‚ùå WRONG - Made up based on pattern:
- id: "my-waf"
  type: "CD-V2-AWS-WAF-FIREWALL"  # FAILS - not the exact referenceId

# ‚úÖ CORRECT - Complete referenceId copied EXACTLY from components.json:
- id: "my-waf"
  type: "CD-V2-AWS-WAF-WEB-APPLICATION-FIREWALL"  # Full string from components.json
```

**More examples:**
```json
// In components.json:
{
  "name": "AWS ECS Cluster",
  "referenceId": "CD-V2-AWS-ECS-CLUSTER",
  "category": "Container Orchestration"
}
```

```yaml
# In your OTM:
- id: "my-cluster"
  type: "CD-V2-AWS-ECS-CLUSTER"  # exact referenceId ‚úÖ
  # NOT: type: "aws-ecs" ‚ùå (abbreviated - fails)
  # NOT: type: "CD-V2-AWS-ECS" ‚ùå (missing -CLUSTER - fails)
  # NOT: type: "CD-V2-ECS-CLUSTER" ‚ùå (missing AWS - fails)
```

**Validation checklist for EACH component:**
- ‚òê Opened components.json and searched for related component
- ‚òê Found exact match by reading `name` field
- ‚òê Copied COMPLETE `referenceId` field value without modification
- ‚òê Verified the referenceId exists in components.json (didn't make it up)

**Rule:** If the referenceId looks redundant or excessively long (e.g., "CD-V2-AWS-WAF-WEB-APPLICATION-FIREWALL"), use it anyway. Do NOT try to "simplify" or "abbreviate" it. If you can't find a component in components.json, use a generic type or skip it - do NOT invent referenceIds.

### Step 4b: Validate References When Updating Existing Threat Models

**‚ö†Ô∏è CRITICAL for Updates:** If updating an existing project, you must verify all referenced IDs exist.

**üö® MOST IMPORTANT: PRESERVE PROJECT ID**

When updating an existing OTM file:
1. **Read the existing OTM file FIRST**
2. **Copy the EXACT project.id value** - this is sacred and immutable
3. **NEVER change project.id** even if you think it should be more descriptive
4. Make your changes ONLY to components, dataflows, trust zones, descriptions
5. Keep project.id exactly as it was

```yaml
# Existing OTM file:
project:
  id: "badger-app-7ozf"  # ‚Üê THIS NEVER CHANGES
  name: "Badger App"

# Updated OTM file (adding payment features):
project:
  id: "badger-app-7ozf"  # ‚Üê SAME ID - NEVER CHANGED
  name: "Badger App with Payments"  # ‚Üê Only name can change
  description: "Now includes payment processing"  # ‚Üê New features described here
```

**For existing projects:**
1. Read `.iriusrisk/project.json` to see current project structure
2. **Read existing OTM file if available to get current project.id**
3. If it exists, also check for an existing OTM export or component list
4. When referencing components in `parent: { component: "x" }` or dataflows, verify that component ID exists
5. When referencing trust zones in `parent: { trustZone: "x" }`, verify that trust zone ID exists in trust-zones.json

**Validation rules:**
- **PROJECT ID:** Must be EXACTLY the same as existing OTM or project.json reference_id
- **Component parent references:** The parent component ID must exist either in the current OTM or be defined earlier in the same OTM file
- **Dataflow references:** Both source and destination component IDs must exist in the OTM's components section
- **Trust zone references:** The trust zone ID must exist in trust-zones.json AND in the OTM's trustZones section
- **Do NOT reference components that don't exist** - this causes import failures

### Step 5: import_otm() - Upload to IriusRisk

Call **import_otm("[path-to-otm-file.otm]")**

What happens:
- **Validates OTM against official JSON schema** (catches structural issues)
- Uploads OTM file to IriusRisk
- Creates new project or updates existing
- Triggers automatic threat generation
- Returns project ID, name, and status

**Schema validation catches:**
- Missing required fields (project.id, component.parent, etc.)
- Invalid data types
- Malformed structure
- Missing trust zones or components referenced in dataflows
- Any deviation from OTM specification

If validation fails, you'll see clear error messages showing exactly what's wrong and where.

**üö® CRITICAL: If import_otm() Fails**

When import fails with an error (401, 403, 400, etc.), you MUST:

‚úÖ **DO:**
- STOP immediately - do not try again
- Report the exact error message to the user
- For 401/403 errors: Tell user the project may have pending changes in IriusRisk UI that need to be confirmed/discarded
- For 400 errors: Check OTM syntax (dataflows, component types, trust zones)
- Ask user to fix the underlying issue

‚ùå **NEVER DO:**
- Change the project.id and try again
- Modify the OTM file randomly hoping it will work
- Try different variations of project IDs
- Assume you can "fix" it by changing fields
- Make multiple import attempts with different IDs

**Common import failures:**
- **401 Unauthorized**: Project has uncommitted changes in IriusRisk UI, or locked/read-only
- **400 Bad Request**: OTM syntax error (dataflows using trust zone IDs, invalid component types)
- **Conflict**: Project ID mismatch between OTM and existing project

Report the error, explain what it likely means, and let the user resolve it. Do NOT attempt workarounds.

### Step 6: project_status() - Verify Success

Call **project_status()**

Verifies:
- Project exists and accessible
- Import processing complete
- Project ready for use
- No error messages

### Step 7: Present Results & Offer Options - STOP HERE

**‚ö†Ô∏è CRITICAL: Do NOT automatically run sync() to download threats/countermeasures.**

**Why NOT automatic:**
- IriusRisk needs time to process the threat model and generate threats
- Running sync() immediately often results in empty threats (countermeasures may download, but threats will be empty)
- User may want to refine the architecture first
- User may want to complete questionnaires first for more accurate threat analysis
- User controls the pace and timing

**What to do:**
1. Summarize what was accomplished:
   - Number of components mapped
   - Trust zones used
   - Dataflows created
   - Successful import confirmation
   
2. **Present options and WAIT for user decision:**
   - **Option A:** "I can complete questionnaires to refine the threat model based on your actual implementation (RECOMMENDED - more accurate results)"
   - **Option B:** "I can download the generated threats and countermeasures now (IriusRisk may still be processing)"
   - **Option C:** "Would you like to refine the architecture before proceeding?"
   - **Option D:** "What would you like to do next?"

3. **WAIT for user response** - do not proceed automatically

**‚ö†Ô∏è IMPORTANT: Completing questionnaires (Option A) is RECOMMENDED before downloading threats because:**
- It makes the threat model more accurate by incorporating actual implementation details
- Reduces false positives (e.g., removes authentication threats if auth is implemented)
- Focuses threats on real gaps in security posture
- Only adds a few minutes but significantly improves quality of results

**If user chooses Option A (questionnaires):**
- Call **questionnaire_guidance()** to get detailed instructions on completing questionnaires
- This will guide you through analyzing code and answering questions to refine the threat model

### Step 8: sync() Again - Download Security Findings (ONLY When User Explicitly Requests)

**‚ö†Ô∏è Only proceed to this step when the user explicitly asks to download threats/countermeasures.**

When user requests, call **sync(project_path)** again to download:
- Generated threats (threats.json)
- Generated countermeasures (countermeasures.json)
- Complete threat model data

**Timing note:** If threats.json is empty after sync, IriusRisk may still be processing. Inform user to wait a minute and try again.

### Step 9: Analysis and Refinement

**After completing questionnaires (if user chose that option):**
- Threat model has been refined based on actual implementation
- False positives reduced
- Threats now focus on actual security gaps

**After downloading security data, you have two analysis tools:**

1. **questionnaire_guidance()** - For completing questionnaires (call this BEFORE downloading threats if possible):
   - Analyzes source code to answer architecture and component questions
   - Tracks questionnaire answers for sync back to IriusRisk
   - Significantly improves threat model accuracy
   - Reduces false positives

2. **threats_and_countermeasures()** - For analyzing downloaded threats:
   - Reading threats.json and countermeasures.json
   - Explaining security findings to users
   - Generating code examples and implementation guidance
   - Security analysis best practices

## Trust Zone Guidelines

**‚ö†Ô∏è DO NOT use these as literal trust zone IDs.** These are conceptual examples only.

**ALWAYS read `.iriusrisk/trust-zones.json` to find:**
- Available trust zones in your IriusRisk instance
- Exact `id` field values (usually UUIDs like "b61d6911-338d-11e8-8c37-ad2a1d5c1e0c")
- Trust rating values for each zone
- Descriptive names to help you choose appropriate zones

**Common trust zone patterns (names may vary in your instance):**
- Internet/External (rating: 1) - External-facing, public APIs, third-party services
- DMZ/Public Cloud (rating: 3-5) - Load balancers, web servers, API gateways
- Internal/Application (rating: 5-7) - Application servers, internal APIs, business logic
- Secure/Private (rating: 7-10) - Databases, auth servers, sensitive data storage

**To use a trust zone:**
1. Read trust-zones.json
2. Find zone with appropriate name and trust rating
3. Copy its `id` value (not the `name`)
4. Use that exact `id` in your component's `parent: { trustZone: "id-here" }`

## Final Validation Checklist

**üö® MANDATORY PRE-FLIGHT VALIDATION - DO NOT SKIP:**

**Component Type Validation (MOST COMMON FAILURE):**
- ‚òê **Opened and read `.iriusrisk/components.json`**
- ‚òê **Filtered out deprecated components** (category.name !== "Deprecated" AND name does NOT start with "Deprecated - ")
- ‚òê **For EVERY component in OTM: Searched components.json for ACTIVE (non-deprecated) type**
- ‚òê **For EVERY component in OTM: Verified COMPLETE referenceId exists** (not abbreviated, not invented)
- ‚òê **If component type not found: Used generic alternative or asked user** (did NOT invent or use deprecated)

**Trust Zone Validation (SECOND MOST COMMON FAILURE):**
- ‚òê **Opened and read `.iriusrisk/trust-zones.json`**
- ‚òê **For EVERY trust zone in OTM: Verified exact UUID ID exists in trust-zones.json**
- ‚òê **Used UUID IDs from `id` field** (not descriptive names from `name` field)
- ‚òê **Did NOT invent trust zone IDs** (every ID came from the file)

**Initial Setup:**
- ‚òê Used sync() first - Downloaded components.json AND trust-zones.json
- ‚òê Read components.json for component type mapping (not CLI commands)
- ‚òê Read trust-zones.json and identified available trust zones with their UUIDs
- ‚òê If updating existing project: Read project.json or exported OTM to know existing component IDs

**OTM Structure:**
- ‚òê Created OTM with ONLY architecture (no threats/controls)
- ‚òê **Verified EVERY component has a parent (trustZone or component)**

**Reference Validation (CRITICAL):**
- ‚òê **Verified all trust zone IDs in `parent: { trustZone: "x" }` exist in trust-zones.json**
- ‚òê **Verified all component IDs in `parent: { component: "x" }` exist in the OTM's components section (defined earlier/above)**
- ‚òê **Verified all dataflow source IDs exist in the OTM's components section**
- ‚òê **Verified all dataflow destination IDs exist in the OTM's components section**
- ‚òê **Validated no dataflows use trust zone IDs (must use component IDs only)**

**Upload:**
- ‚òê Used import_otm() to upload
- ‚òê Used project_status() to verify
- ‚òê Presented user with options and STOPPED (did not auto-sync)

**Remember:**
- AI role: Architecture modeling only
- IriusRisk role: Threat identification and security analysis (automatic)
- **TOP ERRORS TO AVOID (IN ORDER OF FREQUENCY):**
  1. **Using deprecated components** - Filter: category.name !== "Deprecated" AND name does NOT start with "Deprecated - " (~40% are deprecated!)
  2. **Inventing component types** - EVERY component type MUST exist in components.json - Open the file and verify BEFORE using!
  3. **Inventing trust zone IDs** - EVERY trust zone ID MUST exist in trust-zones.json - Open the file and verify BEFORE using!
  4. **Abbreviating component referenceIds** - Use COMPLETE string from components.json (e.g., "CD-V2-AWS-WAF-WEB-APPLICATION-FIREWALL" not "CD-V2-AWS-WAF")
  5. **Assuming components exist** - Never assume - always validate in components.json
  6. **Components without parents** - Every component MUST have trustZone or component parent
  7. **Referencing non-existent components** - All parent/dataflow component IDs must exist in OTM
  8. **Using trust zone IDs in dataflows** - Dataflows connect components only
- **MANDATORY PRE-SUBMISSION VALIDATION (DO NOT SKIP):**
  1. **Open components.json** - For EVERY component type in your OTM, search the file and verify exact referenceId exists
  2. **Filter deprecated** - Verify NO components have category.name="Deprecated" or name starting with "Deprecated - "
  3. **Open trust-zones.json** - For EVERY trust zone ID in your OTM, verify exact UUID exists in the file
  4. **If not found or deprecated** - DO NOT use that component/trust zone - find active alternative or ask user
  5. List all component IDs defined in your OTM
  6. Verify every parent component reference is in that list
  7. Verify every dataflow source/destination is in that list
  
**Validation is not optional - it is THE MOST CRITICAL step. 80% of OTM import failures are due to:**
1. **Using deprecated components** (40% of components are deprecated - MUST filter them out)
2. **Invented/invalid component types or trust zone IDs**
